# Лабораторна робота №4
## Тема: EL, JSTL
## Виконав(-ли): Ковальчук Станіслав, Сухоручкін Гліб, Янович Марія і Ястремський Богдан
---
## Контрольні питання:
### 1. В чому полягають переваги/недоліки використання EL та JSTL у порівнянні з такими JSP-елементами як вирази (<%=…  %>) та скриптлети (<% … %>)?

**Переваги:**
- Простота читання та розуміння коду: EL дозволяє використовувати зрозумілі вирази, такі як ${variable} або ${object.property}, що полегшує читання та розуміння коду.
- Більша безпека: EL дозволяє уникнути проблем з екранизацією вхідних даних, таких як XSS (Cross-Site Scripting), оскільки вбудовані функції EL автоматично екранують спеціальні символи.
- Підтримка колекцій та керування потоком: JSTL надає багато тегів для роботи з колекціями даних (наприклад, <c:forEach>) та керування потоком (наприклад, <c:if>), що спрощує обробку даних на сторінці JSP.
- Легкість використання: EL та JSTL вимагають менше коду порівняно з виразами та скриптлетами, що полегшує розробку та підтримку коду.

**Недоліки EL та JSTL:**
- Обмежена функціональність: EL та JSTL не завжди можуть замінити повністю скриптлети, особливо в складних сценаріях, де потрібен великий контроль над Java-кодом.
- Швидкість виконання: Хоча це не так важливо для більшості додатків, EL та JSTL можуть бути трохи повільнішими у виконанні порівняно з виразами та скриптлетами через додатковий шар абстракції.

### 2. В чому полягають переваги/недоліки використання JSTL-елемента <c:out> у порівнянні зі звичайними EL-виразом ${…} або JSP-елементом <%=… %>?

**Переваги <c:out>**:
- Екранування HTML-спецсимволів: Одна з основних переваг <c:out> полягає в тому, що він автоматично екранує HTML-спецсимволи, такі як <, >, &, що дозволяє уникнути проблем з XSS (Cross-Site Scripting).
- Підтримка виразів: <c:out> дозволяє використовувати вирази як значення атрибуту value, що дає більшу гнучкість у відображенні даних.
- Читабельність: Використання <c:out> може зробити код більш зрозумілим, особливо коли потрібно вивести складний вираз або значення з об'єкта.

**Недоліки <c:out>**:
- Додаткова складність коду: Порівняно зі звичайними EL-виразами ${...}, використання <c:out> може зробити код трохи складнішим через додатковий тег та атрибути.
- Можливість некоректної обробки деяких символів: Іноді <c:out> може неправильно обробляти деякі символи, що може вплинути на відображення даних, особливо якщо використовуються спец. символи, такі як & або '.

### 3. Що таке JavaBeans і як за допомогою EL можна отримувати з них інформацію для відображення на JSP-сторінках?

JavaBeans - це концепція в програмуванні на Java, яка використовується для створення і управління Java-об'єктами, які представляють дані. JavaBeans є простими класами, які мають публічні властивості з методами доступу (геттери та сеттери) та безаргументний конструктор. Ці об'єкти використовуються для зберігання та передачі даних між компонентами програми, такими як сервлети та JSP-сторінки.

Отже, для отримання інформації з JavaBeans для відображення на JSP-сторінках за допомогою EL слід виконати такі кроки:

**Створення JavaBean:**
Створіть клас JavaBean, який має публічні властивості з методами доступу (геттери та сеттери) для даних, які ви хочете відобразити на JSP-сторінці. Наприклад:

```java
public class UserBean {
    private String username;
    private int age;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

**Створення об'єкта JavaBean у сервлеті чи контролері:**

В сервлеті чи іншому контролері створіть об'єкт JavaBean і заповніть його даними:

```java
UserBean user = new UserBean();
user.setUsername("JohnDoe");
user.setAge(25);
request.setAttribute("user", user); // Передача об'єкта на JSP-сторінку через атрибут request
```

**Використання EL на JSP-сторінці для відображення даних:**

На JSP-сторінці використовуйте EL для отримання даних з JavaBean та їх відображення. Наприклад:

```jsp
Copy code
<body>
    <h1>Welcome ${user.username}</h1>
    <p>Your age is ${user.age}</p>
</body>
```

### 4. Який час життя атрибутів на рівнях  requestScope, sessionScope, applicationScope?

- **requestScope:** життєвий цикл протягом одного запиту-відповіді.
- **sessionScope:** життєвий цикл від початку сесії до завершення або видалення сесії.
- **applicationScope:** життєвий цикл від початку запуску до зупинення або перезапуску веб-додатку.

### 5. Що таке ServletContext і як з JSP та сервлетів звертатись до атрибутів, що були збережені на його рівні?

`ServletContext` є об'єктом, який представляє контекст додатка у сервлет-аплікаціях Java EE. Цей об'єкт дозволяє зберігати глобальні атрибути, які будуть доступні для всіх сервлетів у межах даного веб-додатка. Кожен веб-додаток має свій власний `ServletContext`, який існує впродовж життєвого циклу додатка.

Щоб звертатись до атрибутів, збережених на рівні `ServletContext`, з JSP та сервлетів, слід виконати наступні дії:

### З JSP:
1. **Збереження атрибута в `ServletContext` в сервлеті:**
   ```java
   // В сервлеті
   getServletContext().setAttribute("attributeName", attributeValue);
   ```

2. **Отримання атрибута з `ServletContext` у JSP:**
   ```jsp
   <%@ page import="javax.servlet.ServletContext" %>
   <% ServletContext servletContext = request.getServletContext(); %>
   <% Object attributeValue = servletContext.getAttribute("attributeName"); %>
   ```

### З сервлетів:
1. **Збереження атрибута в `ServletContext` в сервлеті:**
   ```java
   // В сервлеті
   getServletContext().setAttribute("attributeName", attributeValue);
   ```

2. **Отримання атрибута з `ServletContext` у сервлеті:**
   ```java
   // В сервлеті
   Object attributeValue = getServletContext().getAttribute("attributeName");
   ```

Зверніть увагу, що у JSP для використання `ServletContext` потрібно вказати директиву `@ page import="javax.servlet.ServletContext"`, яка дозволяє імпортувати клас `ServletContext`. Далі в JSP можна отримати доступ до `ServletContext` через об'єкт `request`, викликавши метод `request.getServletContext()`.

Атрибути, збережені на рівні `ServletContext`, є глобальними для всього додатка і доступними з будь-якого сервлета або JSP, що належить до цього додатка. Це дозволяє передавати дані та налаштування між різними компонентами додатка.

### 6. Чи можуть існувати атрибути з однаковими іменами на різних рівнях (наприклад на рівні requestScope та sessionScope)?

Так, можуть існувати атрибути з однаковими іменами на різних рівнях видимості в Java EE, таких як `requestScope`, `sessionScope`, `applicationScope` (або `ServletContext` у випадку глобальних атрибутів). Кожен рівень видимості має своє власне пространство імен для атрибутів, тому атрибути з однаковими іменами на різних рівнях не будуть конфліктувати між собою.

Ось приклад, як це працює:

1. **requestScope:**
   Якщо ви збережете атрибут з ім'ям "user" в `requestScope`:
   ```java
   request.setAttribute("user", userObject);
   ```
   То цей атрибут буде доступний тільки в межах поточного HTTP запиту.

2. **sessionScope:**
   Якщо ви також збережете атрибут з ім'ям "user" в `sessionScope`:
   ```java
   HttpSession session = request.getSession();
   session.setAttribute("user", userObject);
   ```
   То цей атрибут буде доступний протягом усієї сесії користувача, а не тільки в межах одного запиту.

Кожен рівень видимості має свої власні області для зберігання атрибутів і кожен атрибут зберігається відповідно до свого рівня. Це дозволяє розробникам зберігати та отримувати дані на різних рівнях із тими самими іменами без конфліктів.

### 7. В чому полягають переваги використання шаблона MVC?

Шаблон MVC (Model-View-Controller) є одним із найбільш популярних та ефективних архітектурних шаблонів у розробці програмного забезпечення. Він розділяє компоненти додатка на три основні частини: модель (Model), представлення (View) та контролер (Controller). Ось деякі переваги використання шаблону MVC:

1. **Розділення відповідальностей:** Однією з основних переваг MVC є розділення відповідальностей між компонентами додатка. Модель відповідає за бізнес-логіку та доступ до даних, представлення відповідає за відображення інтерфейсу користувача, а контролер відповідає за обробку вхідних запитів та управління потоком додатка. Це розділення сприяє покращенню структури коду та його підтримці.

2. **Покращена повторне використання коду:** Завдяки розділенню на модель, представлення та контролер, можливо використовувати ці компоненти знову та знову у різних частинах додатка або навіть у різних додатках. Наприклад, модель може бути використана в кількох контролерах або представлення може бути перевикористане у різних виглядах.

3. **Легка змінність та підтримка:** Зміни у логіці додатка або в інтерфейсі користувача можуть вноситися окремо без значних змін у інших частинах додатка. Це дозволяє забезпечити більшу гнучкість та швидкість розробки.

4. **Тестованість:** Через розділення на модель, представлення та контролер, компоненти додатка можуть бути легко та ефективно протестовані окремо. Це дозволяє виконувати модульні та інтеграційні тести для кожної частини додатка.

5. **Підтримка паралельної розробки:** Команді розробників можна дозволити працювати над різними частинами додатка паралельно, оскільки кожен компонент MVC може бути незалежно розвинутим та тестованим.

В цілому, шаблон MVC сприяє поліпшенню структури додатка, зменшенню залежностей між його компонентами, підвищенню його гнучкості та підтримки, а також забезпечує зручність у розробці та тестуванні програмного забезпечення.

### 8. Поясніть призначення та принцип дії шаблону проектування Front Controller.

Шаблон проектування Front Controller є одним з ключових шаблонів веб-програмування та реалізує основний принцип централізованої обробки запитів у веб-додатку. Основним призначенням Front Controller є централізоване керування всіма запитами, які надходять до додатка, та диспетчеризація їх на відповідні обробники.

Принцип дії шаблону Front Controller включає наступні етапи:

1. **Централізація обробки запитів:** У шаблоні Front Controller всі HTTP-запити веб-додатка спрямовуються на один центральний контролер (Front Controller). Цей контролер відповідає за прийом усіх запитів та їх подальшу обробку.

2. **Визначення маршрутів:** Front Controller визначає маршрутизацію запитів на основі шаблонів URL, HTTP методів або інших параметрів запиту. Наприклад, `/user/login` може бути маршрутом для обробки запитів на аутентифікацію користувача.

3. **Диспетчеризація запитів:** Після визначення маршруту Front Controller відправляє запит до відповідного обробника (контролера), який відповідає за обробку даного типу запиту. Цей обробник може бути, наприклад, сервлетом у Java EE додатках або контролером у фреймворках MVC.

4. **Обробка запиту:** Контролер (обробник) отримує запит від Front Controller і виконує необхідні дії для обробки запиту. Це може включати перевірку доступу, валідацію даних, виклик сервісів для обробки бізнес-логіки та підготовку даних для відображення.

5. **Повернення відповіді:** Після обробки запиту контролер повертає відповідь, яка може бути HTML сторінкою, JSON об'єктом або іншим типом відповіді, залежно від типу запиту та логіки додатка.

Головна перевага шаблону Front Controller полягає в тому, що він дозволяє централізовано керувати усіма запитами та діями в додатку, що полегшує підтримку, розширення та відладку коду. Також цей шаблон сприяє введенню стандартизованої обробки запитів та дозволяє легко додавати нові функції та фічі в додаток.

---
## Висновки:
У ході цієї лаборатоної роботи, ми дізналися багато нової інформації про принципи роботи JSP, EL, JSTL спробували примінити свої знання на практиці, створюючи власну сторінку з їх використанням, і закріпили здобуту теоретичну базу, відповідаючи на контрольні питання.
